import { JsonType, FeatureFlagValue, PostHogCoreOptions, PostHogFetchOptions, PostHogFetchResponse, Logger, PostHogCoreStateless, PostHogPersistedProperty, PostHogFlagsAndPayloadsResponse, PostHogEventProperties, PostHogCaptureOptions } from '@posthog/core';
import * as http from 'node:http';

declare const severityLevels: readonly ["fatal", "error", "warning", "log", "info", "debug"];
declare type SeverityLevel = (typeof severityLevels)[number];
interface EventHint {
    mechanism?: Partial<Mechanism>;
    syntheticException?: Error | null;
}
interface Mechanism {
    handled?: boolean;
    type?: string;
    source?: string;
    synthetic?: boolean;
}
type StackParser = (stack: string, skipFirstLines?: number) => StackFrame[];
type StackFrameModifierFn = (frames: StackFrame[]) => Promise<StackFrame[]>;
interface StackFrame {
    platform: string;
    filename?: string;
    function?: string;
    module?: string;
    lineno?: number;
    colno?: number;
    abs_path?: string;
    context_line?: string;
    pre_context?: string[];
    post_context?: string[];
    in_app?: boolean;
    instruction_addr?: string;
    addr_mode?: string;
    vars?: {
        [key: string]: JsonType;
    };
    chunk_id?: string;
}

interface IdentifyMessage {
    distinctId: string;
    properties?: Record<string | number, any>;
    disableGeoip?: boolean;
}
interface SendFeatureFlagsOptions {
    onlyEvaluateLocally?: boolean;
    personProperties?: Record<string, any>;
    groupProperties?: Record<string, Record<string, any>>;
    flagKeys?: string[];
}
interface EventMessage extends IdentifyMessage {
    event: string;
    groups?: Record<string, string | number>;
    sendFeatureFlags?: boolean | SendFeatureFlagsOptions;
    timestamp?: Date;
    uuid?: string;
}
interface GroupIdentifyMessage {
    groupType: string;
    groupKey: string;
    properties?: Record<string | number, any>;
    distinctId?: string;
    disableGeoip?: boolean;
}
type PropertyGroup = {
    type: 'AND' | 'OR';
    values: PropertyGroup[] | FlagProperty[];
};
type FlagProperty = {
    key: string;
    type?: string;
    value: FlagPropertyValue;
    operator?: string;
    negation?: boolean;
    dependency_chain?: string[];
};
type FlagPropertyValue = string | number | (string | number)[] | boolean;
type FeatureFlagCondition = {
    properties: FlagProperty[];
    rollout_percentage?: number;
    variant?: string;
};
type BeforeSendFn = (event: EventMessage | null) => EventMessage | null;
type PostHogOptions = PostHogCoreOptions & {
    persistence?: 'memory';
    personalApiKey?: string;
    privacyMode?: boolean;
    enableExceptionAutocapture?: boolean;
    featureFlagsPollingInterval?: number;
    maxCacheSize?: number;
    fetch?: (url: string, options: PostHogFetchOptions) => Promise<PostHogFetchResponse>;
    enableLocalEvaluation?: boolean;
    /**
     * Allows modification or dropping of events before they're sent to PostHog.
     * If an array is provided, the functions are run in order.
     * If a function returns null, the event will be dropped.
     */
    before_send?: BeforeSendFn | BeforeSendFn[];
};
type PostHogFeatureFlag = {
    id: number;
    name: string;
    key: string;
    filters?: {
        aggregation_group_type_index?: number;
        groups?: FeatureFlagCondition[];
        multivariate?: {
            variants: {
                key: string;
                rollout_percentage: number;
            }[];
        };
        payloads?: Record<string, string>;
    };
    deleted: boolean;
    active: boolean;
    rollout_percentage: null | number;
    ensure_experience_continuity: boolean;
    experiment_set: number[];
};
interface IPostHog {
    /**
     * @description Capture allows you to capture anything a user does within your system,
     * which you can later use in PostHog to find patterns in usage,
     * work out which features to improve or where people are giving up.
     * A capture call requires:
     * @param distinctId which uniquely identifies your user
     * @param event We recommend using [verb] [noun], like movie played or movie updated to easily identify what your events mean later on.
     * @param properties OPTIONAL | which can be a object with any information you'd like to add
     * @param groups OPTIONAL | object of what groups are related to this event, example: { company: 'id:5' }. Can be used to analyze companies instead of users.
     * @param sendFeatureFlags OPTIONAL | Used with experiments. Determines whether to send feature flag values with the event.
     */
    capture({ distinctId, event, properties, groups, sendFeatureFlags }: EventMessage): void;
    /**
     * @description Capture an event immediately. Useful for edge environments where the usual queue-based sending is not preferable. Do not mix immediate and non-immediate calls.
     * @param distinctId which uniquely identifies your user
     * @param event We recommend using [verb] [noun], like movie played or movie updated to easily identify what your events mean later on.
     * @param properties OPTIONAL | which can be a object with any information you'd like to add
     * @param groups OPTIONAL | object of what groups are related to this event, example: { company: 'id:5' }. Can be used to analyze companies instead of users.
     * @param sendFeatureFlags OPTIONAL | Used with experiments. Determines whether to send feature flag values with the event.
     */
    captureImmediate({ distinctId, event, properties, groups, sendFeatureFlags }: EventMessage): Promise<void>;
    /**
     * @description Identify lets you add metadata on your users so you can more easily identify who they are in PostHog,
     * and even do things like segment users by these properties.
     * An identify call requires:
     * @param distinctId which uniquely identifies your user
     * @param properties with a dict with any key: value pairs
     */
    identify({ distinctId, properties }: IdentifyMessage): void;
    /**
     * @description Identify lets you add metadata on your users so you can more easily identify who they are in PostHog.
     * Useful for edge environments where the usual queue-based sending is not preferable. Do not mix immediate and non-immediate calls.
     * @param distinctId which uniquely identifies your user
     * @param properties with a dict with any key: value pairs
     */
    identifyImmediate({ distinctId, properties }: IdentifyMessage): Promise<void>;
    /**
     * @description To marry up whatever a user does before they sign up or log in with what they do after you need to make an alias call.
     * This will allow you to answer questions like "Which marketing channels leads to users churning after a month?"
     * or "What do users do on our website before signing up?"
     * In a purely back-end implementation, this means whenever an anonymous user does something, you'll want to send a session ID with the capture call.
     * Then, when that users signs up, you want to do an alias call with the session ID and the newly created user ID.
     * The same concept applies for when a user logs in. If you're using PostHog in the front-end and back-end,
     *  doing the identify call in the frontend will be enough.:
     * @param distinctId the current unique id
     * @param alias the unique ID of the user before
     */
    alias(data: {
        distinctId: string;
        alias: string;
    }): void;
    /**
     * @description To marry up whatever a user does before they sign up or log in with what they do after you need to make an alias call.
     * Useful for edge environments where the usual queue-based sending is not preferable. Do not mix immediate and non-immediate calls.
     * @param distinctId the current unique id
     * @param alias the unique ID of the user before
     */
    aliasImmediate(data: {
        distinctId: string;
        alias: string;
    }): Promise<void>;
    /**
     * @description PostHog feature flags (https://posthog.com/docs/features/feature-flags)
     * allow you to safely deploy and roll back new features. Once you've created a feature flag in PostHog,
     * you can use this method to check if the flag is on for a given user, allowing you to create logic to turn
     * features on and off for different user groups or individual users.
     * @param key the unique key of your feature flag
     * @param distinctId the current unique id
     * @param options: dict with optional parameters below
     * @param groups optional - what groups are currently active (group analytics). Required if the flag depends on groups.
     * @param personProperties optional - what person properties are known. Used to compute flags locally, if personalApiKey is present.
     * @param groupProperties optional - what group properties are known. Used to compute flags locally, if personalApiKey is present.
     * @param onlyEvaluateLocally optional - whether to only evaluate the flag locally. Defaults to false.
     * @param sendFeatureFlagEvents optional - whether to send feature flag events. Used for Experiments. Defaults to true.
     *
     * @returns true if the flag is on, false if the flag is off, undefined if there was an error.
     */
    isFeatureEnabled(key: string, distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        sendFeatureFlagEvents?: boolean;
    }): Promise<boolean | undefined>;
    /**
     * @description PostHog feature flags (https://posthog.com/docs/features/feature-flags)
     * allow you to safely deploy and roll back new features. Once you've created a feature flag in PostHog,
     * you can use this method to check if the flag is on for a given user, allowing you to create logic to turn
     * features on and off for different user groups or individual users.
     * @param key the unique key of your feature flag
     * @param distinctId the current unique id
     * @param options: dict with optional parameters below
     * @param groups optional - what groups are currently active (group analytics). Required if the flag depends on groups.
     * @param personProperties optional - what person properties are known. Used to compute flags locally, if personalApiKey is present.
     * @param groupProperties optional - what group properties are known. Used to compute flags locally, if personalApiKey is present.
     * @param onlyEvaluateLocally optional - whether to only evaluate the flag locally. Defaults to false.
     * @param sendFeatureFlagEvents optional - whether to send feature flag events. Used for Experiments. Defaults to true.
     *
     * @returns true or string(for multivariates) if the flag is on, false if the flag is off, undefined if there was an error.
     */
    getFeatureFlag(key: string, distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        sendFeatureFlagEvents?: boolean;
    }): Promise<FeatureFlagValue | undefined>;
    /**
     * @description Retrieves payload associated with the specified flag and matched value that is passed in.
     *
     * IMPORTANT: The `matchValue` parameter should be the value you previously obtained from `getFeatureFlag()`.
     * If matchValue isn't passed (or is undefined), this method will automatically call `getFeatureFlag()`
     * internally to fetch the flag value, which could result in a network call to the PostHog server if this flag can
     * not be evaluated locally. This means that omitting `matchValue` will potentially:
     * - Bypass local evaluation
     * - Count as an additional flag evaluation against your quota
     * - Impact performance due to the extra network request
     *
     * Example usage:
     * ```js
     * const flagValue = await client.getFeatureFlag('my-flag', distinctId);
     * const payload = await client.getFeatureFlagPayload('my-flag', distinctId, flagValue);
     * ```
     *
     * @param key the unique key of your feature flag
     * @param distinctId the current unique id
     * @param matchValue The flag value previously obtained from calling `getFeatureFlag()`. Can be a string or boolean.
     *                   To avoid extra network calls, pass this parameter when you can.
     * @param options: dict with optional parameters below
     * @param onlyEvaluateLocally optional - whether to only evaluate the flag locally. Defaults to false.
     *
     * @returns payload of a json type object
     */
    getFeatureFlagPayload(key: string, distinctId: string, matchValue?: FeatureFlagValue, options?: {
        onlyEvaluateLocally?: boolean;
    }): Promise<JsonType | undefined>;
    /**
     * @description Sets a groups properties, which allows asking questions like "Who are the most active companies"
     * using my product in PostHog.
     *
     * @param groupType Type of group (ex: 'company'). Limited to 5 per project
     * @param groupKey Unique identifier for that type of group (ex: 'id:5')
     * @param properties OPTIONAL | which can be a object with any information you'd like to add
     */
    groupIdentify({ groupType, groupKey, properties }: GroupIdentifyMessage): void;
    /**
     * @description Force an immediate reload of the polled feature flags. Please note that they are
     * already polled automatically at a regular interval.
     */
    reloadFeatureFlags(): Promise<void>;
    /**
     * @description Flushes the events still in the queue and clears the feature flags poller to allow for
     * a clean shutdown.
     *
     * @param shutdownTimeoutMs The shutdown timeout, in milliseconds. Defaults to 30000 (30s).
     */
    shutdown(shutdownTimeoutMs?: number): void;
    /**
     * @description Waits for local evaluation to be ready, with an optional timeout.
     * @param timeoutMs - Maximum time to wait in milliseconds. Defaults to 30 seconds.
     * @returns A promise that resolves to true if local evaluation is ready, false if the timeout was reached.
     */
    waitForLocalEvaluationReady(timeoutMs?: number): Promise<boolean>;
    /**
     * @description Returns true if local evaluation is ready, false if it's not.
     * @returns true if local evaluation is ready, false if it's not.
     */
    isLocalEvaluationReady(): boolean;
}

declare class ErrorTracking {
    private client;
    private _exceptionAutocaptureEnabled;
    private _rateLimiter;
    private _logger;
    static stackParser: StackParser;
    static frameModifiers: StackFrameModifierFn[];
    constructor(client: PostHogBackendClient, options: PostHogOptions, _logger: Logger);
    static buildEventMessage(error: unknown, hint: EventHint, distinctId?: string, additionalProperties?: Record<string | number, any>): Promise<EventMessage>;
    private startAutocaptureIfEnabled;
    private onException;
    private onFatalError;
    isEnabled(): boolean;
    shutdown(): void;
}

declare abstract class PostHogBackendClient extends PostHogCoreStateless implements IPostHog {
    private _memoryStorage;
    private featureFlagsPoller?;
    protected errorTracking: ErrorTracking;
    private maxCacheSize;
    private logger;
    readonly options: PostHogOptions;
    distinctIdHasSentFlagCalls: Record<string, string[]>;
    /**
     * Initialize a new PostHog client instance.
     *
     * @example
     * ```ts
     * // Basic initialization
     * const client = new PostHogBackendClient(
     *   'your-api-key',
     *   { host: 'https://app.posthog.com' }
     * )
     * ```
     *
     * @example
     * ```ts
     * // With personal API key
     * const client = new PostHogBackendClient(
     *   'your-api-key',
     *   {
     *     host: 'https://app.posthog.com',
     *     personalApiKey: 'your-personal-api-key'
     *   }
     * )
     * ```
     *
     * {@label Initialization}
     *
     * @param apiKey - Your PostHog project API key
     * @param options - Configuration options for the client
     */
    constructor(apiKey: string, options?: PostHogOptions);
    /**
     * Get a persisted property value from memory storage.
     *
     * @example
     * ```ts
     * // Get user ID
     * const userId = client.getPersistedProperty('userId')
     * ```
     *
     * @example
     * ```ts
     * // Get session ID
     * const sessionId = client.getPersistedProperty('sessionId')
     * ```
     *
     * {@label Initialization}
     *
     * @param key - The property key to retrieve
     * @returns The stored property value or undefined if not found
     */
    getPersistedProperty(key: PostHogPersistedProperty): any | undefined;
    /**
     * Set a persisted property value in memory storage.
     *
     * @example
     * ```ts
     * // Set user ID
     * client.setPersistedProperty('userId', 'user_123')
     * ```
     *
     * @example
     * ```ts
     * // Set session ID
     * client.setPersistedProperty('sessionId', 'session_456')
     * ```
     *
     * {@label Initialization}
     *
     * @param key - The property key to set
     * @param value - The value to store (null to remove)
     */
    setPersistedProperty(key: PostHogPersistedProperty, value: any | null): void;
    /**
     * Make an HTTP request using the configured fetch function or default fetch.
     *
     * @example
     * ```ts
     * // POST request
     * const response = await client.fetch('/api/endpoint', {
     *   method: 'POST',
     *   headers: { 'Content-Type': 'application/json' },
     *   body: JSON.stringify(data)
     * })
     * ```
     *
     * @internal
     *
     * {@label Initialization}
     *
     * @param url - The URL to fetch
     * @param options - Fetch options
     * @returns Promise resolving to the fetch response
     */
    fetch(url: string, options: PostHogFetchOptions): Promise<PostHogFetchResponse>;
    /**
     * Get the library version from package.json.
     *
     * @example
     * ```ts
     * // Get version
     * const version = client.getLibraryVersion()
     * console.log(`Using PostHog SDK version: ${version}`)
     * ```
     *
     * {@label Initialization}
     *
     * @returns The current library version string
     */
    getLibraryVersion(): string;
    /**
     * Get the custom user agent string for this client.
     *
     * @example
     * ```ts
     * // Get user agent
     * const userAgent = client.getCustomUserAgent()
     * // Returns: "posthog-node/5.7.0"
     * ```
     *
     * {@label Identification}
     *
     * @returns The formatted user agent string
     */
    getCustomUserAgent(): string;
    /**
     * Enable the PostHog client (opt-in).
     *
     * @example
     * ```ts
     * // Enable client
     * await client.enable()
     * // Client is now enabled and will capture events
     * ```
     *
     * {@label Privacy}
     *
     * @returns Promise that resolves when the client is enabled
     */
    enable(): Promise<void>;
    /**
     * Disable the PostHog client (opt-out).
     *
     * @example
     * ```ts
     * // Disable client
     * await client.disable()
     * // Client is now disabled and will not capture events
     * ```
     *
     * {@label Privacy}
     *
     * @returns Promise that resolves when the client is disabled
     */
    disable(): Promise<void>;
    /**
     * Enable or disable debug logging.
     *
     * @example
     * ```ts
     * // Enable debug logging
     * client.debug(true)
     * ```
     *
     * @example
     * ```ts
     * // Disable debug logging
     * client.debug(false)
     * ```
     *
     * {@label Initialization}
     *
     * @param enabled - Whether to enable debug logging
     */
    debug(enabled?: boolean): void;
    /**
     * Capture an event manually.
     *
     * @example
     * ```ts
     * // Basic capture
     * client.capture({
     *   distinctId: 'user_123',
     *   event: 'button_clicked',
     *   properties: { button_color: 'red' }
     * })
     * ```
     *
     * {@label Capture}
     *
     * @param props - The event properties
     * @returns void
     */
    capture(props: EventMessage): void;
    /**
     * Capture an event immediately (synchronously).
     *
     * @example
     * ```ts
     * // Basic immediate capture
     * await client.captureImmediate({
     *   distinctId: 'user_123',
     *   event: 'button_clicked',
     *   properties: { button_color: 'red' }
     * })
     * ```
     *
     * @example
     * ```ts
     * // With feature flags
     * await client.captureImmediate({
     *   distinctId: 'user_123',
     *   event: 'user_action',
     *   sendFeatureFlags: true
     * })
     * ```
     *
     * @example
     * ```ts
     * // With custom feature flags options
     * await client.captureImmediate({
     *   distinctId: 'user_123',
     *   event: 'user_action',
     *   sendFeatureFlags: {
     *     onlyEvaluateLocally: true,
     *     personProperties: { plan: 'premium' },
     *     groupProperties: { org: { tier: 'enterprise' } }
     *     flagKeys: ['flag1', 'flag2']
     *   }
     * })
     * ```
     *
     * {@label Capture}
     *
     * @param props - The event properties
     * @returns Promise that resolves when the event is captured
     */
    captureImmediate(props: EventMessage): Promise<void>;
    /**
     * Identify a user and set their properties.
     *
     * @example
     * ```ts
     * // Basic identify with properties
     * client.identify({
     *   distinctId: 'user_123',
     *   properties: {
     *     name: 'John Doe',
     *     email: 'john@example.com',
     *     plan: 'premium'
     *   }
     * })
     * ```
     *
     * @example
     * ```ts
     * // Using $set and $set_once
     * client.identify({
     *   distinctId: 'user_123',
     *   properties: {
     *     $set: { name: 'John Doe', email: 'john@example.com' },
     *     $set_once: { first_login: new Date().toISOString() }
     *   }
     * })
     * ```
     *
     * {@label Identification}
     *
     * @param data - The identify data containing distinctId and properties
     */
    identify({ distinctId, properties, disableGeoip }: IdentifyMessage): void;
    /**
     * Identify a user and set their properties immediately (synchronously).
     *
     * @example
     * ```ts
     * // Basic immediate identify
     * await client.identifyImmediate({
     *   distinctId: 'user_123',
     *   properties: {
     *     name: 'John Doe',
     *     email: 'john@example.com'
     *   }
     * })
     * ```
     *
     * {@label Identification}
     *
     * @param data - The identify data containing distinctId and properties
     * @returns Promise that resolves when the identify is processed
     */
    identifyImmediate({ distinctId, properties, disableGeoip }: IdentifyMessage): Promise<void>;
    /**
     * Create an alias to link two distinct IDs together.
     *
     * @example
     * ```ts
     * // Link an anonymous user to an identified user
     * client.alias({
     *   distinctId: 'anonymous_123',
     *   alias: 'user_456'
     * })
     * ```
     *
     * {@label Identification}
     *
     * @param data - The alias data containing distinctId and alias
     */
    alias(data: {
        distinctId: string;
        alias: string;
        disableGeoip?: boolean;
    }): void;
    /**
     * Create an alias to link two distinct IDs together immediately (synchronously).
     *
     * @example
     * ```ts
     * // Link an anonymous user to an identified user immediately
     * await client.aliasImmediate({
     *   distinctId: 'anonymous_123',
     *   alias: 'user_456'
     * })
     * ```
     *
     * {@label Identification}
     *
     * @param data - The alias data containing distinctId and alias
     * @returns Promise that resolves when the alias is processed
     */
    aliasImmediate(data: {
        distinctId: string;
        alias: string;
        disableGeoip?: boolean;
    }): Promise<void>;
    /**
     * Check if local evaluation of feature flags is ready.
     *
     * @example
     * ```ts
     * // Check if ready
     * if (client.isLocalEvaluationReady()) {
     *   // Local evaluation is ready, can evaluate flags locally
     *   const flag = await client.getFeatureFlag('flag-key', 'user_123')
     * } else {
     *   // Local evaluation not ready, will use remote evaluation
     *   const flag = await client.getFeatureFlag('flag-key', 'user_123')
     * }
     * ```
     *
     * {@label Feature flags}
     *
     * @returns true if local evaluation is ready, false otherwise
     */
    isLocalEvaluationReady(): boolean;
    /**
     * Wait for local evaluation of feature flags to be ready.
     *
     * @example
     * ```ts
     * // Wait for local evaluation
     * const isReady = await client.waitForLocalEvaluationReady()
     * if (isReady) {
     *   console.log('Local evaluation is ready')
     * } else {
     *   console.log('Local evaluation timed out')
     * }
     * ```
     *
     * @example
     * ```ts
     * // Wait with custom timeout
     * const isReady = await client.waitForLocalEvaluationReady(10000) // 10 seconds
     * ```
     *
     * {@label Feature flags}
     *
     * @param timeoutMs - Timeout in milliseconds (default: 30000)
     * @returns Promise that resolves to true if ready, false if timed out
     */
    waitForLocalEvaluationReady(timeoutMs?: number): Promise<boolean>;
    /**
     * Get the value of a feature flag for a specific user.
     *
     * @example
     * ```ts
     * // Basic feature flag check
     * const flagValue = await client.getFeatureFlag('new-feature', 'user_123')
     * if (flagValue === 'variant-a') {
     *   // Show variant A
     * } else if (flagValue === 'variant-b') {
     *   // Show variant B
     * } else {
     *   // Flag is disabled or not found
     * }
     * ```
     *
     * @example
     * ```ts
     * // With groups and properties
     * const flagValue = await client.getFeatureFlag('org-feature', 'user_123', {
     *   groups: { organization: 'acme-corp' },
     *   personProperties: { plan: 'enterprise' },
     *   groupProperties: { organization: { tier: 'premium' } }
     * })
     * ```
     *
     * @example
     * ```ts
     * // Only evaluate locally
     * const flagValue = await client.getFeatureFlag('local-flag', 'user_123', {
     *   onlyEvaluateLocally: true
     * })
     * ```
     *
     * {@label Feature flags}
     *
     * @param key - The feature flag key
     * @param distinctId - The user's distinct ID
     * @param options - Optional configuration for flag evaluation
     * @returns Promise that resolves to the flag value or undefined
     */
    getFeatureFlag(key: string, distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        sendFeatureFlagEvents?: boolean;
        disableGeoip?: boolean;
    }): Promise<FeatureFlagValue | undefined>;
    /**
     * Get the payload for a feature flag.
     *
     * @example
     * ```ts
     * // Get payload for a feature flag
     * const payload = await client.getFeatureFlagPayload('flag-key', 'user_123')
     * if (payload) {
     *   console.log('Flag payload:', payload)
     * }
     * ```
     *
     * @example
     * ```ts
     * // Get payload with specific match value
     * const payload = await client.getFeatureFlagPayload('flag-key', 'user_123', 'variant-a')
     * ```
     *
     * @example
     * ```ts
     * // With groups and properties
     * const payload = await client.getFeatureFlagPayload('org-flag', 'user_123', undefined, {
     *   groups: { organization: 'acme-corp' },
     *   personProperties: { plan: 'enterprise' }
     * })
     * ```
     *
     * {@label Feature flags}
     *
     * @param key - The feature flag key
     * @param distinctId - The user's distinct ID
     * @param matchValue - Optional match value to get payload for
     * @param options - Optional configuration for flag evaluation
     * @returns Promise that resolves to the flag payload or undefined
     */
    getFeatureFlagPayload(key: string, distinctId: string, matchValue?: FeatureFlagValue, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        /** @deprecated THIS OPTION HAS NO EFFECT, kept here for backwards compatibility reasons. */
        sendFeatureFlagEvents?: boolean;
        disableGeoip?: boolean;
    }): Promise<JsonType | undefined>;
    /**
     * Get the remote config payload for a feature flag.
     *
     * @example
     * ```ts
     * // Get remote config payload
     * const payload = await client.getRemoteConfigPayload('flag-key')
     * if (payload) {
     *   console.log('Remote config payload:', payload)
     * }
     * ```
     *
     * {@label Feature flags}
     *
     * @param flagKey - The feature flag key
     * @returns Promise that resolves to the remote config payload or undefined
     * @throws Error if personal API key is not provided
     */
    getRemoteConfigPayload(flagKey: string): Promise<JsonType | undefined>;
    /**
     * Check if a feature flag is enabled for a specific user.
     *
     * @example
     * ```ts
     * // Basic feature flag check
     * const isEnabled = await client.isFeatureEnabled('new-feature', 'user_123')
     * if (isEnabled) {
     *   // Feature is enabled
     *   console.log('New feature is active')
     * } else {
     *   // Feature is disabled
     *   console.log('New feature is not active')
     * }
     * ```
     *
     * @example
     * ```ts
     * // With groups and properties
     * const isEnabled = await client.isFeatureEnabled('org-feature', 'user_123', {
     *   groups: { organization: 'acme-corp' },
     *   personProperties: { plan: 'enterprise' }
     * })
     * ```
     *
     * {@label Feature flags}
     *
     * @param key - The feature flag key
     * @param distinctId - The user's distinct ID
     * @param options - Optional configuration for flag evaluation
     * @returns Promise that resolves to true if enabled, false if disabled, undefined if not found
     */
    isFeatureEnabled(key: string, distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        sendFeatureFlagEvents?: boolean;
        disableGeoip?: boolean;
    }): Promise<boolean | undefined>;
    /**
     * Get all feature flag values for a specific user.
     *
     * @example
     * ```ts
     * // Get all flags for a user
     * const allFlags = await client.getAllFlags('user_123')
     * console.log('User flags:', allFlags)
     * // Output: { 'flag-1': 'variant-a', 'flag-2': false, 'flag-3': 'variant-b' }
     * ```
     *
     * @example
     * ```ts
     * // With specific flag keys
     * const specificFlags = await client.getAllFlags('user_123', {
     *   flagKeys: ['flag-1', 'flag-2']
     * })
     * ```
     *
     * @example
     * ```ts
     * // With groups and properties
     * const orgFlags = await client.getAllFlags('user_123', {
     *   groups: { organization: 'acme-corp' },
     *   personProperties: { plan: 'enterprise' }
     * })
     * ```
     *
     * {@label Feature flags}
     *
     * @param distinctId - The user's distinct ID
     * @param options - Optional configuration for flag evaluation
     * @returns Promise that resolves to a record of flag keys and their values
     */
    getAllFlags(distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        disableGeoip?: boolean;
        flagKeys?: string[];
    }): Promise<Record<string, FeatureFlagValue>>;
    /**
     * Get all feature flag values and payloads for a specific user.
     *
     * @example
     * ```ts
     * // Get all flags and payloads for a user
     * const result = await client.getAllFlagsAndPayloads('user_123')
     * console.log('Flags:', result.featureFlags)
     * console.log('Payloads:', result.featureFlagPayloads)
     * ```
     *
     * @example
     * ```ts
     * // With specific flag keys
     * const result = await client.getAllFlagsAndPayloads('user_123', {
     *   flagKeys: ['flag-1', 'flag-2']
     * })
     * ```
     *
     * @example
     * ```ts
     * // Only evaluate locally
     * const result = await client.getAllFlagsAndPayloads('user_123', {
     *   onlyEvaluateLocally: true
     * })
     * ```
     *
     * {@label Feature flags}
     *
     * @param distinctId - The user's distinct ID
     * @param options - Optional configuration for flag evaluation
     * @returns Promise that resolves to flags and payloads
     */
    getAllFlagsAndPayloads(distinctId: string, options?: {
        groups?: Record<string, string>;
        personProperties?: Record<string, string>;
        groupProperties?: Record<string, Record<string, string>>;
        onlyEvaluateLocally?: boolean;
        disableGeoip?: boolean;
        flagKeys?: string[];
    }): Promise<PostHogFlagsAndPayloadsResponse>;
    /**
     * Create or update a group and its properties.
     *
     * @example
     * ```ts
     * // Create a company group
     * client.groupIdentify({
     *   groupType: 'company',
     *   groupKey: 'acme-corp',
     *   properties: {
     *     name: 'Acme Corporation',
     *     industry: 'Technology',
     *     employee_count: 500
     *   },
     *   distinctId: 'user_123'
     * })
     * ```
     *
     * @example
     * ```ts
     * // Update organization properties
     * client.groupIdentify({
     *   groupType: 'organization',
     *   groupKey: 'org-456',
     *   properties: {
     *     plan: 'enterprise',
     *     region: 'US-West'
     *   }
     * })
     * ```
     *
     * {@label Identification}
     *
     * @param data - The group identify data
     */
    groupIdentify({ groupType, groupKey, properties, distinctId, disableGeoip }: GroupIdentifyMessage): void;
    /**
     * Reload feature flag definitions from the server for local evaluation.
     *
     * @example
     * ```ts
     * // Force reload of feature flags
     * await client.reloadFeatureFlags()
     * console.log('Feature flags reloaded')
     * ```
     *
     * @example
     * ```ts
     * // Reload before checking a specific flag
     * await client.reloadFeatureFlags()
     * const flag = await client.getFeatureFlag('flag-key', 'user_123')
     * ```
     *
     * {@label Feature flags}
     *
     * @returns Promise that resolves when flags are reloaded
     */
    reloadFeatureFlags(): Promise<void>;
    /**
     * Shutdown the PostHog client gracefully.
     *
     * @example
     * ```ts
     * // Shutdown with default timeout
     * await client._shutdown()
     * ```
     *
     * @example
     * ```ts
     * // Shutdown with custom timeout
     * await client._shutdown(5000) // 5 seconds
     * ```
     *
     * {@label Shutdown}
     *
     * @param shutdownTimeoutMs - Timeout in milliseconds for shutdown
     * @returns Promise that resolves when shutdown is complete
     */
    _shutdown(shutdownTimeoutMs?: number): Promise<void>;
    private _requestRemoteConfigPayload;
    private extractPropertiesFromEvent;
    private getFeatureFlagsForEvent;
    private addLocalPersonAndGroupProperties;
    /**
     * Capture an error exception as an event.
     *
     * @example
     * ```ts
     * // Capture an error with user ID
     * try {
     *   // Some risky operation
     *   riskyOperation()
     * } catch (error) {
     *   client.captureException(error, 'user_123')
     * }
     * ```
     *
     * @example
     * ```ts
     * // Capture with additional properties
     * try {
     *   apiCall()
     * } catch (error) {
     *   client.captureException(error, 'user_123', {
     *     endpoint: '/api/users',
     *     method: 'POST',
     *     status_code: 500
     *   })
     * }
     * ```
     *
     * {@label Error tracking}
     *
     * @param error - The error to capture
     * @param distinctId - Optional user distinct ID
     * @param additionalProperties - Optional additional properties to include
     */
    captureException(error: unknown, distinctId?: string, additionalProperties?: Record<string | number, any>): void;
    /**
     * Capture an error exception as an event immediately (synchronously).
     *
     * @example
     * ```ts
     * // Capture an error immediately with user ID
     * try {
     *   // Some risky operation
     *   riskyOperation()
     * } catch (error) {
     *   await client.captureExceptionImmediate(error, 'user_123')
     * }
     * ```
     *
     * @example
     * ```ts
     * // Capture with additional properties
     * try {
     *   apiCall()
     * } catch (error) {
     *   await client.captureExceptionImmediate(error, 'user_123', {
     *     endpoint: '/api/users',
     *     method: 'POST',
     *     status_code: 500
     *   })
     * }
     * ```
     *
     * {@label Error tracking}
     *
     * @param error - The error to capture
     * @param distinctId - Optional user distinct ID
     * @param additionalProperties - Optional additional properties to include
     * @returns Promise that resolves when the error is captured
     */
    captureExceptionImmediate(error: unknown, distinctId?: string, additionalProperties?: Record<string | number, any>): Promise<void>;
    prepareEventMessage(props: EventMessage): Promise<{
        distinctId: string;
        event: string;
        properties: PostHogEventProperties;
        options: PostHogCaptureOptions;
    }>;
    private _runBeforeSend;
}

/**
 * @file Adapted from [posthog-js](https://github.com/PostHog/posthog-js/blob/8157df935a4d0e71d2fefef7127aa85ee51c82d1/src/extensions/sentry-integration.ts) with modifications for the Node SDK.
 */
/**
 * Integrate Sentry with PostHog. This will add a direct link to the person in Sentry, and an $exception event in PostHog.
 *
 * ### Usage
 *
 *     Sentry.init({
 *          dsn: 'https://example',
 *          integrations: [
 *              new PostHogSentryIntegration(posthog)
 *          ]
 *     })
 *
 *     Sentry.setTag(PostHogSentryIntegration.POSTHOG_ID_TAG, 'some distinct id');
 *
 * @param {Object} [posthog] The posthog object
 * @param {string} [organization] Optional: The Sentry organization, used to send a direct link from PostHog to Sentry
 * @param {Number} [projectId] Optional: The Sentry project id, used to send a direct link from PostHog to Sentry
 * @param {string} [prefix] Optional: Url of a self-hosted sentry instance (default: https://sentry.io/organizations/)
 * @param {SeverityLevel[] | '*'} [severityAllowList] Optional: send events matching the provided levels. Use '*' to send all events (default: ['error'])
 * @param {boolean} [sendExceptionsToPostHog] Optional: capture exceptions as events in PostHog (default: true)
 */

type _SentryEvent = any;
type _SentryEventProcessor = any;
type _SentryHub = any;
interface _SentryIntegration {
    name: string;
    processEvent(event: _SentryEvent): _SentryEvent;
}
interface _SentryIntegrationClass {
    name: string;
    setupOnce(addGlobalEventProcessor: (callback: _SentryEventProcessor) => void, getCurrentHub: () => _SentryHub): void;
}
type SentryIntegrationOptions = {
    organization?: string;
    projectId?: number;
    prefix?: string;
    severityAllowList?: SeverityLevel[] | '*';
    sendExceptionsToPostHog?: boolean;
};
declare function createEventProcessor(_posthog: PostHogBackendClient, { organization, projectId, prefix, severityAllowList, sendExceptionsToPostHog, }?: SentryIntegrationOptions): (event: _SentryEvent) => _SentryEvent;
declare function sentryIntegration(_posthog: PostHogBackendClient, options?: SentryIntegrationOptions): _SentryIntegration;
declare class PostHogSentryIntegration implements _SentryIntegrationClass {
    readonly name = "posthog-node";
    static readonly POSTHOG_ID_TAG = "posthog_distinct_id";
    setupOnce: (addGlobalEventProcessor: (callback: _SentryEventProcessor) => void, getCurrentHub: () => _SentryHub) => void;
    constructor(_posthog: PostHogBackendClient, organization?: string, prefix?: string, severityAllowList?: SeverityLevel[] | '*', sendExceptionsToPostHog?: boolean);
}

type ExpressMiddleware = (req: http.IncomingMessage, res: http.ServerResponse, next: () => void) => void;
type ExpressErrorMiddleware = (error: MiddlewareError, req: http.IncomingMessage, res: http.ServerResponse, next: (error: MiddlewareError) => void) => void;
interface MiddlewareError extends Error {
    status?: number | string;
    statusCode?: number | string;
    status_code?: number | string;
    output?: {
        statusCode?: number | string;
    };
}
declare function setupExpressErrorHandler(_posthog: PostHogBackendClient, app: {
    use: (middleware: ExpressMiddleware | ExpressErrorMiddleware) => unknown;
}): void;

declare class PostHog extends PostHogBackendClient {
    getLibraryId(): string;
}

export { type BeforeSendFn, type EventMessage, type FeatureFlagCondition, type FlagProperty, type FlagPropertyValue, type GroupIdentifyMessage, type IPostHog, type IdentifyMessage, PostHog, type PostHogFeatureFlag, type PostHogOptions, PostHogSentryIntegration, type PropertyGroup, type SendFeatureFlagsOptions, type SentryIntegrationOptions, createEventProcessor, sentryIntegration, setupExpressErrorHandler };
